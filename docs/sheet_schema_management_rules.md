# シートスキーマ（タブ/ヘッダ）をコードで管理する運用ルール（AI向け）

## 0. 前提

- 本プロジェクトの Apps Script は **スプレッドシートに紐づく（bound）**。
- 実装は **ローカルで TypeScript**、GAS への反映は **ビルド成果物を `clasp push`**。
- スプレッドシートは人が触る（手修正/列追加/列移動/シート名変更等が起こり得る）前提で、**壊れにくさ**を最優先する。
- いったんの管理対象は **A: タブ + ヘッダ（列構造）** のみ（書式、保護、検証、NamedRange 等はスコープ外）。

---

## 1. 目的（AIが守るべきゴール）

- スプレッドシートの構造を「口頭/暗黙」ではなく **コード（定義）で再現可能**にする。
- 人が触っても壊れにくいように、アプリ側は **列番号に依存しない**（ヘッダ名→列番号の解決）。
- 変更を安全に進めるために、**非破壊の同期（sync）** と **破壊的変更（migration）** を分離する。

---

## 2. 用語

- **スキーマ**: シート（タブ）名、ヘッダ行位置、ヘッダ名（列定義）の集合。
- **ドリフト**: 人手などで実シートがスキーマ定義からズレた状態。
- **sync（同期）**: 不足分だけを補う非破壊操作（作成/不足列追加など）。
- **migration（移行）**: 破壊的/意味変更を含む操作（列リネーム、列削除、データ移送など）。

---

## 3. 管理ルール（AIの行動規範）

### 3.1 「コードが正」だが「自動で壊さない」

- スキーマのソースオブトゥルースは **`schema.ts`（予定）** とする。
- ただし、ドリフト検知で差分が見つかっても、**列削除・列リネーム・データ消去を自動実行しない**。
  - これらは migration として明示的に設計し、影響範囲/ロールバック手順込みで変更する。

### 3.2 参照は「ヘッダ名」ベース（列番号固定禁止）

- J列/W列などの固定参照は原則禁止。
- 「ヘッダ名→列番号」を毎回解決し、見つからない場合は **異常として扱い**、ログへ出す。

### 3.3 どの Properties を使うか（bound 前提）

- スキーマバージョンやスプレッドシート固有の状態は **`PropertiesService.getDocumentProperties()`** に保存する。
  - 理由: bound のためスプレッドシート単位で状態を持てる。ScriptProperties だと他シートへコピーした時に事故りやすい。
- 例: `SCHEMA_VERSION` / `LAST_SCHEMA_SYNC_AT` / `LAST_SCHEMA_DRIFT_AT` など。

### 3.4 排他（同時実行）ルール

- `syncSchema()` / `migrate()` は必ず **`LockService.getDocumentLock()`**（または ScriptLock）で排他する。
  - 目的: 同時実行で列追加などが競合し、スキーマが壊れるのを防ぐ。

---

## 4. 開発ルール（実装の型）

### 4.1 推奨構成（TypeScript）

- `src/schema/schema.ts`
  - 管理対象のシート定義（シート名、ヘッダ行、列定義）
- `src/schema/syncSchema.ts`
  - 非破壊の同期（不足シート作成、不足列追加、ヘッダ設定）
- `src/schema/migrations/*`
  - 破壊的/意味変更が必要な場合の個別 migration
- `src/schema/migrate.ts`
  - DocumentProperties の `SCHEMA_VERSION` を見て順に migration を適用
- `src/ui/menu.ts`
  - 管理者メニュー（手動で `syncSchema`/`migrate`/`checkDrift` を実行）

※実際のパスはこのリポジトリ構成に合わせて調整してよいが、「schema定義」と「同期/移行」を分けることが重要。

### 4.2 syncSchema の責務（非破壊）

- シートが無ければ作る（`insertSheet`）
- ヘッダ行を作る/不足ヘッダを追加する
- ヘッダ名の表記ゆれがあり得る場合は、**許容する別名（aliases）**を定義して吸収する（ただし自動リネームはしない）

**禁止（syncSchema でやらない）**

- 列削除
- 列名の強制リネーム
- 既存データの移送/書き換え

### 4.3 migration の責務（破壊的/意味変更）

以下が必要になったら migration を作る：

- 列名変更（例: `管理部門` → `管理部署`）
- 列削除
- 既存列から新列へデータ移送
- シート名変更（互換のための旧→新のコピー等）

migration は **冪等**にし、実行前提条件（存在チェック）とログを入れる。

### 4.4 ドリフト検知（必須）

- `checkSchemaDrift()` を用意し、以下を検出してログ化する：
  - 管理対象シートが存在しない
  - ヘッダ行が違う/空
  - 必須ヘッダが足りない
  - 想定外のヘッダが増えている（これは警告止まり）
- ドリフトは「直す」より先に「見える化」する（通知ログ/実行ログへ記録）。

---

## 5. 変更手順（AIが提案すべき運用）

### 5.1 新しい列を追加したい（非破壊）

1. `schema.ts` の列定義に追加
2. `syncSchema()` が不足列を追加できることを確認
3. 手動メニューで `syncSchema()` を実行（またはデプロイ時に実行）

### 5.2 列名を変えたい（破壊的）

1. 旧列名/新列名、影響するロジック（参照ヘッダ）を洗い出す
2. migration を作る（例: 旧列があれば新列へコピーして、旧列は残す/後で削除、など段階的）
3. 参照側は「旧/新どちらでも読める」期間を設ける（移行猶予）

### 5.3 人が列を動かした/増やした（ドリフト）

- アプリはヘッダ名で列解決するため、列移動は基本的に問題にならない設計にする。
- ヘッダ名が変わった/消えた場合は、`checkSchemaDrift()` で検知し、**処理を止める**（誤列書き込み防止）。

---

## 6. AIレビュー・チェックリスト（この領域のPR/差分を出す前に）

- [ ] 列参照が列番号固定になっていない（ヘッダ名解決になっている）
- [ ] sync と migration が混ざっていない（syncが破壊しない）
- [ ] SchemaVersion は `DocumentProperties` に保存している（bound 前提）
- [ ] `LockService` による排他がある
- [ ] ドリフト検知があり、異常時は安全側に倒れる（止める/ログ出す）

